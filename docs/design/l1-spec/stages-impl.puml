@startuml

state "<b>Opened</b>" as Opened
Opened: * ""Amount""
Opened: * ""Snapshot""
Opened: * ""Period""

state "<b>Closed</b>" as Closed
Closed: * ""Amount""
Closed: * ""Squash""
Closed: * ""Timeout""
Closed: * ""Pend""

state "<b>Responded</b>" as Responded
Responded: * ""Amount""
Responded: * ""Pend""
Responded: * ""Pend""

state "<b>Elapsed</b>" as Elapsed
Elapsed: * ""Pend""

state "<b>Resolved</b>" as Resolved
Resolved: * ""Pend""
Resolved: * ""Pend""

[*] --> Opened : <b>open</b>\nby opener
note on link
  * In all stages we keep a tuple of verification keys.
  * The initial order of keys is `(opener, non-opener)`.
  * The `Amount` reflects the non-opener balance.
  * The `Total - Amount` is the opener balance.
end note

Opened --u-> Opened : ""<b>add</b>""

Opened --> Closed : <b>close</b>\nby closer
note on link
* Close.In : Input state
  - Close.In.0 : Keys `keys_in`
  - Close.In.1 : `Opened(amt1_in, snapshot_in, period_in) = stage_in`
  - Close.In.2 : Amount `tot_in`

* Close.Out : Output state
  - Close.Out.0 : Keys `keys_out`
  - Close.Out.1 :
    `Closed(amt_out, squash_out, timeout_out, pend_out) = stage_out`
  - Close.Out.2 : Amount `tot_out`

* Close.Con : Constraints
  - Close.Con.0 : If tx signed by `vk0` then `keys_in == keys_out` else keys are
    swaped
  - Close.Con.1 : If no snapshot provided then `snapshot_out` equals
    `snapshot_in`

  - Close.Con.2 : Else

    - Close.Con.2.0 : Snapshot signed by other key
    - Close.Con.2.1 : `snapshot_out` equals provided union `snapshot_in`

  - Close.Con.3 : `ReduceCheck` succeeds with `chqs_amt` for the provided
    cheques and the `pend_out`
  - Close.Con.4 : `amt_in + chqs_amt + sq_diff == amt_out` where
    `amt_in = tot_in - amt1_in` if the closer is also the opener else
    `amt_in = amt1_in` `sq_diff` is the difference of the squashes in the latest
    snapshot
  - Close.Con.5 : `sq_out == sq_sent`
  - Close.Con.6 : `timeout_out > ub + respond_period`
  - Close.Con.7 : `tot_out >= tot_in`
end note

Closed --u-> Closed : <b>free</b>\nby closer
Closed --d-> Responded : <b>respond</b>\nby non-closer
note on link
  * Releases non-closer account assets.
  * The left over should cover the closer account
  and potential liabilities of the non-closer which
  are stored in their `Pend`.
  * The `Pend`s are stored in order corresponding to the keys.
end note

Closed --d-> Elapsed : <b>elapse</b>\nby closer
note on link
  * Releases account assets.
  * For simplicity we disallow the closer to provide
  cheques owned by the non-closer.
  * The left over should cover just the
  non-closer account as any extra liabilities
  of the closer were ignored.
end note

Responded --u-> Responded : <b>free</b>\nby non-closer
Responded --d-> Resolved : <b>resolve</b>\nby closer
note on link
  * Releases account assets leaving coverage for liabilities.
end note
Responded --> [*] : <b>end</b>\nby closer

Elapsed --u-> Elapsed : <b>free</b>\nby closer
Elapsed --d-> Resolved : <b>resolve</b>\nby non-closer
note on link
  * Releases account assets but covering his liabilities.
  * Non-closer `Pend` is empty - we ignored them during `elapse`.
end note
Elapsed --d-> [*] : <b>end</b>
note on link
  * Possibly releases account
  assets to non-closer.
end note

Resolved --u-> Resolved : <b>free</b>
Resolved --> [*] : <b>end</b>

@enduml


// pub type CStep {
//   Add(Option<Signed<Snapshot>>)
//   Close(Receipt)
//   Respond(Receipt, DropOld)
//   Resolve(Secrets, DropOld)
//   Elapse(Secrets)
//   Free(Secrets, DropOld)
// }
